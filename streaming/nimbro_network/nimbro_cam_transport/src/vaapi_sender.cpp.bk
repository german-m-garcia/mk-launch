// VAAPI_H264 sender
// Author: German M.

#include <ros/ros.h>

#include <image_transport/image_transport.h>

#include <sensor_msgs/CompressedImage.h>

#include <cv_bridge/cv_bridge.h>
#include <opencv2/opencv.hpp>


#include <x264.h>
#define HAVE_AVHWCTX
extern "C" {
#include <libavcodec/avcodec.h>
#include <libavutil/pixdesc.h>
#include <libavutil/hwcontext.h>
}

#include "rgb_to_yuv420.h"

ros::Time g_lastImageTime(0);
ros::Duration g_minTimeBetweenImages;


std::vector<uint8_t> g_inBuf;
x264_t* g_encoder = 0;
int g_encoderConfiguredHeight;

x264_picture_t g_inputPicture;
x264_picture_t g_outPicture;

ros::Publisher g_pub;

double g_crf;


static int width, height;
static AVBufferRef *hw_device_ctx = NULL;
AVCodecContext *avctx = NULL;
AVFrame *sw_frame = NULL, *hw_frame = NULL;
cv::Mat resized;


static int set_hwframe_ctx(AVCodecContext *ctx, AVBufferRef *hw_device_ctx)
{
    AVBufferRef *hw_frames_ref;
    AVHWFramesContext *frames_ctx = NULL;
    int err = 0;

    if (!(hw_frames_ref = av_hwframe_ctx_alloc(hw_device_ctx))) {
        fprintf(stderr, "Failed to create VAAPI frame context.\n");
        return -1;
    }
    frames_ctx = (AVHWFramesContext *)(hw_frames_ref->data);
    frames_ctx->format    = AV_PIX_FMT_VAAPI;
    frames_ctx->sw_format = AV_PIX_FMT_NV12;
    frames_ctx->width     = width;
    frames_ctx->height    = height;
    frames_ctx->initial_pool_size = 20;
    if ((err = av_hwframe_ctx_init(hw_frames_ref)) < 0) {
        ROS_ERROR_STREAM("Failed to initialize VAAPI frame context. Error code: " << err);
        av_buffer_unref(&hw_frames_ref);
        return err;
    }
    ctx->hw_frames_ctx = av_buffer_ref(hw_frames_ref);
    if (!ctx->hw_frames_ctx)
        err = AVERROR(ENOMEM);

    av_buffer_unref(&hw_frames_ref);
    return err;
}

void init_sw_frame(){
	int err = 0;
	if (!(sw_frame = av_frame_alloc())) 
	{
		ROS_ERROR_STREAM("av_frame_alloc err=" << AVERROR(ENOMEM) );
		return;
	}
	/* read data into software frame, and transfer them into hw frame */
	sw_frame->width  = width;
	sw_frame->height = height;
	sw_frame->format = AV_PIX_FMT_YUV420P; //AV_PIX_FMT_NV12;
	if ((err = av_frame_get_buffer(sw_frame, 32)) < 0)
	{
		ROS_ERROR_STREAM("av_frame_get_buffer err=" << err );
		return;
	}
}

void init_hw_frame(){
	int err = 0;
	if (!(hw_frame = av_frame_alloc())) {
		ROS_ERROR_STREAM("av_frame_alloc hwframe err=" << err );
		return;
	}
	if ((err = av_hwframe_get_buffer(avctx->hw_frames_ctx, hw_frame, 0)) < 0) {
		ROS_ERROR_STREAM("av_frame_get_buffer err=" << err );
		return;
	}
	if (!hw_frame->hw_frames_ctx) {
		ROS_ERROR_STREAM("hw_frames_ctx is null" );
		return;
	}
}

int init_vaapi(int w, int h)
{
	int size, err;
    FILE *fin = NULL, *fout = NULL;    
    AVCodec *codec = NULL;
    const char *enc_name = "h264_vaapi";    

    width  = 640;
    height = 480;
    size   = width * height;

	g_inBuf.resize(width*height + width*height/2);
    

    err = av_hwdevice_ctx_create(&hw_device_ctx, AV_HWDEVICE_TYPE_VAAPI,
                                 NULL, NULL, 0);
    if (err < 0) 
	{
		ROS_ERROR_STREAM("Failed to create a VAAPI device. Error code: " << err);
        return -1;
    }

    if (!(codec = avcodec_find_encoder_by_name(enc_name)))
	{
        ROS_ERROR("Could not find H264 VAAPI encoder.");
        return -1;
    }

    if (!(avctx = avcodec_alloc_context3(codec)))
	{
        err = AVERROR(ENOMEM);
        return -1;
    }

    avctx->width     = width;
    avctx->height    = height;
    avctx->time_base = (AVRational){1, 25};
    avctx->framerate = (AVRational){25, 1};
    avctx->sample_aspect_ratio = (AVRational){1, 1};
    avctx->pix_fmt   = AV_PIX_FMT_VAAPI;

    /* set hw_frames_ctx for encoder's AVCodecContext */
    if ((err = set_hwframe_ctx(avctx, hw_device_ctx)) < 0) {
        ROS_ERROR("Failed to set hwframe context.");
        return -1;
    }

    if ((err = avcodec_open2(avctx, codec, NULL)) < 0) {
        ROS_ERROR_STREAM( "Cannot open video encoder codec. Error code: " << err);        
		return -1;
    }

	init_sw_frame();
	init_hw_frame();
	ROS_INFO("Initialized vaapi encoder");

}

static int encode_write(AVFrame *frame, AVPacket& enc_pkt)
{
    int ret = 0;

    av_init_packet(&enc_pkt);
    enc_pkt.data = NULL;
    enc_pkt.size = 0;

    if ((ret = avcodec_send_frame(avctx, frame)) < 0) {
        ROS_ERROR_STREAM("Error code: " << ret);
        return -1;
    }
    
	ret = avcodec_receive_packet(avctx, &enc_pkt);
	if (ret)
		return -1;

	enc_pkt.stream_index = 0;
}

void handleImageVaapi(const sensor_msgs::ImageConstPtr& img)
{
	int err;
	ROS_INFO("handleImageVaapi()...");
	
	ros::Time now = ros::Time::now();
	if(now - g_lastImageTime < g_minTimeBetweenImages)
		return;
	g_lastImageTime = now;

	ros::Time start = ros::Time::now();

	cv_bridge::CvImageConstPtr cvImg = cv_bridge::toCvShare(img, "bgr8");
	// if not itialised
	if(!avctx){		
		init_vaapi(cvImg->image.rows,cvImg->image.cols);		
	}

	//int height = width * cvImg->image.rows / cvImg->image.cols;

	
	cv::resize(cvImg->image, resized, cv::Size(width, height), CV_INTER_AREA);

	RGB_to_YUV420(resized.data, g_inBuf.data(), width, height);

	ROS_INFO("did handleImageVaapi()");
	
	sw_frame->data[0] = g_inBuf.data();
	sw_frame->data[1] = g_inBuf.data() + width*height;
	sw_frame->data[2] = g_inBuf.data() + width*height + width*height/4;

	
	if ((err = av_hwframe_transfer_data(hw_frame, sw_frame, 0)) < 0) {
		ROS_ERROR_STREAM("Error while transferring frame data to surface. err=" << err );
		return;
	}

	AVPacket enc_pkt;
	encode_write(hw_frame, enc_pkt);


	/*
	   ROS publishing
	*/
	sensor_msgs::CompressedImagePtr msg(new sensor_msgs::CompressedImage);

	msg->header = img->header;
	msg->format = "h264";

	msg->data.resize(enc_pkt.size);
	memcpy(msg->data.data() , enc_pkt.data, enc_pkt.size);
		
	g_pub.publish(msg);
}


int main(int argc, char** argv)
{
	ros::init(argc, argv, "vaapi_sender");

	ros::NodeHandle nh("~");

	image_transport::ImageTransport it(nh);

	nh.param("width", width, 640);

	double rate;
	nh.param("rate", rate, 60.0);

	nh.param("crf", g_crf, 30.0);

	g_minTimeBetweenImages = ros::Duration(1.0 / rate);

	g_pub = nh.advertise<sensor_msgs::CompressedImage>("encoded", 1);

	image_transport::Subscriber sub = it.subscribe("/camera/rgb/image_rect_color", 1, &handleImageVaapi);

	ros::spin();

	return 0;
}
